import { useInfiniteQuery, useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { Task, TaskFormData, TasksResponse, TaskPriority } from "../model/types";

const TASK_QUERY_KEY = "tasks";

// Функция для генерации описания
const generateDescription = (title: string, id: number) => {
  const options = [
    `Это важная задача, которая требует внимания. Ключевой элемент нашего плана.`,
    `Требуется выполнить в ближайшее время. Приоритет - высокий.`,
    `Данная задача включает несколько этапов выполнения.`,
    `Описание задачи. Приоритет - высокий, сроки сжатые.`,
    `Задача связана с основными бизнес-процессами компании.`,
  ];
  return options[Math.floor(Math.random() * options.length)];
};

// Случайный приоритет для моковых данных
const getRandomPriority = (): TaskPriority => {
  const priorities: TaskPriority[] = ["low", "medium", "high", "critical"];
  return priorities[Math.floor(Math.random() * priorities.length)];
};

// Создаем мок-данные
const createMockTasks = () => {
  const tasks: Task[] = [];
  for (let i = 0; i < 200; i++) {
    const id = i + 1;
    const titles = [
      `Разработать новый функционал ${id}`,
      `Исправить критическую ошибку ${id}`,
      `Оптимизировать производительность ${id}`,
      `Добавить тесты для модуля ${id}`,
      `Рефакторинг кодовой базы ${id}`,
      `Интеграция с внешним API ${id}`,
      `Создать документацию ${id}`,
    ];
    const title = titles[Math.floor(Math.random() * titles.length)];
    tasks.push({
      id,
      title,
      description: generateDescription(title, id),
      completed: Math.random() > 0.5,
      createdAt: new Date(Date.now() - Math.random() * 10000000000).toISOString(),
      userId: 1,
      priority: getRandomPriority(),
    });
  }
  return tasks;
};

let mockTasks = createMockTasks();

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

export const useTasksInfiniteQuery = () => {
  return useInfiniteQuery({
    queryKey: [TASK_QUERY_KEY, "infinite"],
    queryFn: async ({ pageParam = 0 }): Promise<TasksResponse> => {
      await delay(300);

      const start = pageParam;
      const limit = 20;
      const end = start + limit;

      const tasks = mockTasks.slice(start, end);

      return {
        tasks,
        hasMore: end < mockTasks.length,
        nextCursor: end,
        total: mockTasks.length,
      };
    },
    getNextPageParam: (lastPage) => {
      return lastPage.hasMore ? lastPage.nextCursor : undefined;
    },
    initialPageParam: 0,
  });
};

export const useTaskQuery = (id: number) => {
  return useQuery({
    queryKey: [TASK_QUERY_KEY, id],
    queryFn: async () => {
      await delay(200);
      const task = mockTasks.find(t => t.id === id);
      if (!task) throw new Error("Задача не найдена");
      return task;
    },
    enabled: !!id,
  });
};

export const useCreateTask = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (taskData: TaskFormData) => {
      await delay(500);
      const newTask: Task = {
        id: mockTasks.length + 1,
        ...taskData,
        completed: taskData.completed || false,
        priority: taskData.priority || "medium", // По умолчанию средний приоритет
        createdAt: new Date().toISOString(),
        userId: 1,
      };
      mockTasks.unshift(newTask);
      return newTask;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [TASK_QUERY_KEY] });
    },
  });
};

export const useUpdateTask = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id, ...taskData }: Partial<Task> & { id: number }) => {
      await delay(500);
      const index = mockTasks.findIndex(t => t.id === id);
      if (index === -1) throw new Error("Задача не найдена");

      mockTasks[index] = { ...mockTasks[index], ...taskData };
      return mockTasks[index];
    },
    onSuccess: (updatedTask) => {
      queryClient.invalidateQueries({ queryKey: [TASK_QUERY_KEY] });
      queryClient.invalidateQueries({ queryKey: [TASK_QUERY_KEY, updatedTask.id] });
    },
  });
};

export const useDeleteTask = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (id: number) => {
      await delay(500);
      const index = mockTasks.findIndex(t => t.id === id);
      if (index > -1) {
        mockTasks.splice(index, 1);
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [TASK_QUERY_KEY] });
    },
  });
};
